### 1. (dev) Em sala, discutimos uma implementação de um lock justo, em clang. Esse lock usava uma fila para manter identificadores de pthreads em espera para executar a região crítica. Uma vez liberado o lock, a thread que entrou primeiro na fila deve ser escolhida para executar. Faça uma implementação em java com as mesmas características, seguindo a interface listada abaixo. Sua implementação não pode usar os métodos wait,  notify e notifyAll da classe Object. Use ArrayList para implementar a fila. Você não pode usar synchronized  na declaração de nenhum método criado por você. Você não pode usar nenhum objeto do pacote java.util.concurrent exceto java.util.concurrent.locks.LockSupport.park() para bloquear a execução da Thread corrente e java.util.concurrent.locks.LockSupport.unpark(Thread thread) para desbloquear. Adicionalmente, você pode usar java.util.concurrent.atomic.AtomicInteger  para implementar o equivalente à instrução testAndSet caso topo não usar synchronized  em nenhum ponto do código (nem em um bloco interno).

Uma implementação justa de lock deve permitir que todas as threads tenham chance de executar. De acordo com o enunciado, deve-se utilizar uma fila para manter as threads em espera para executar a região crítica. No funcionamento de uma fila o primeiro elemento que entra é o primeiro a sair, então a thread que entrou primeiro na fila será a escolhida para executar. 
A implementação foi feita em Java, nela estão as classes: Count, TLock e Lock. A seguir será detalhado o funcionamento delas.
*  **Count**: tem o atributo *count* e implementa dois métodos, *get()* e *inc(int v)*, o seu objetivo é adicionar valores ao atributo *count*, essa adição é realizada através do método *inc(int v)*;
* **TCount**: implementa a interface *Runnable*, essa interface define o método *run()*, o qual deve conter o código que será executado pela(s) thread(s). Além disso, essa classe recebe em seu construtor os parâmetros: *count* (instância da classe **Count**) e *l* (instância da classe **Lock**). O método *run()* implementa um loop com 1000 iterações, a cada iteração o método *inc(1)* da classe **Count** é chamado, ou seja, o atributo do tipo inteiro da classe **Count** é incrementado, após a variável ser incrementada, o método imprime "(Id da thread): (valor da variável)". Como o método *run()* será executado por mais de uma thread, o trecho interno ao loop é uma região crítica, pois pode ocorrer o seguinte cenário: Thread1 lê o valor de *count* e perde a CPU, Thread2 lê o valor de *count* e incrementa, quando a Thread1 voltar a executar ela irá incrementar o valor antigo, e isso irá fazer com que o resultado final não seja o esperado, por isso a função *lock()* é chamada na primeira linha interna ao loop e *unlock()* na última linha interna ao loop, garantindo assim a exclusão mútua.
*  **Lock**: nessa classe há 3 atributos: flag (AtomicBoolean), guard (AtomicBoolean) e queue (ArrayList), todos eles são voláteis, ou seja, tem garantia de que o valor atualizado estará sempre disponível para outras threads, sendo gravado na memória principal assim que atualizado, de forma atômica. Além disso, existem os métodos *lock()* e *unlock()*, que servem justamente para garantir a exclusão mútua entre as threads. A implementação do *lock()* foi realizada da seguinte maneira: inicialmente a variável *guard* é utilizada basicamente como um *spin-lock* em torno de *flag* e de *queue*. Nesse caso, utilizar *spin-lock* é uma abordagem razoável, pois o tempo gasto esperando é bastante limitado (apenas algumas instruções dentro do código de lock e unlock, em vez da seção crítica definida pelo usuário). Após esse *spin-lock*, é feita a verificação se a variável *flag* é *false*, se sim, a Thread altera o valor da variável e entra na região crítica, caso contrário, a Thread é adicionada a lista (*queue*), a variável *guard* é alterada para *false*, e a função *park()* é chamada para bloquear a Thread (as verificações dos valores de *flag* e *guard* são feitas utilizando a função *getAndSet(boolean b)*, similar a função *testAndSet(boolean b)*). A implementação do *unlock()* utiliza o mesmo *spin-lock* com a variável *guard* no início (para garantir a exclusão mútua ao adicionar e remover as Threads da fila), após isso, é feita a verificação se a lista está vazia, caso ela não esteja, a Thread na posição 0 é removida da lista (*guard* é alterada para *false*) e colocada para executar (através da função *unpark(thread)*), caso a lista esteja vazia as duas variáveis *flag* e *guard* são alteradas para *false*, pois isso quer dizer que não a nenhuma Thread esperando para ser executada.

Ao final da implementação dessas classes, criamos uma função *main()* para realizar um experimento: foram criadas 6 Threads, todas utilizadas para executar a função *run()* da classe **Count**, o valor inicial passado foi 1. Como a função *run()* implementa um loop com 1000 iterações, esperasse que ao final da execução (na qual todas as 6 Threads executaram) o valor final seja 6000.   
